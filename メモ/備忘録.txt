XMFLOAT3はfloat型３つ分メモリが確保されてそう。00が4つ並んでるのが3つ並んでたから

条件付きブレークポイントはwhileのとことかに置くとFPSクソ下がるぞ

priority_quereの昇順にしたやつ全部が昇順になってるわけでは無くて入れたタイミングで小さかったのと一番近い値と一番後ろから交換してるだけ
つまり小さいやつとそれと近い場所のやつ交換してるだけだから値ぐちゃぐちゃだぞ。後ろに２番目に小さかった奴とか言っちゃってる
って思ったけどtopの時にちゃんと昇順になってました。ごめんあさい

listとvectorの違い；vectorはメモリを並べておくから、必ずメモリがつながってるので、あとから一つ要素を追加した時にvectorの後ろのメモリが
　空いてなかった場合そのvectorのメモリを丸々どっかに引っ越さなきゃいけないせいで追加する時少し遅い
liseは別々のメモリに置くから、追加するのが速くて、色々早い。その代わり一つの要素にアクセスするために毎回イテレータを使わないといけない
　からちょっとアクセスがめんどくさい。
別々にアクセスしたいときはvector、順番にアクセスしたいときはlistみたいな感じでいいか。後から追加する予定が無い時もvectorでいいかも

.atと[]の違い:.at()は範囲外にアクセスしたときにちゃんと例外(out.of.raugeみたいな)出すけど[]は無理やりアクセスするから変な値が出る

push_backとemplace_backの違い:pushは要素をコピーして渡すからコピーコンストラクタとかが逐一呼ばれるからemplaseより重いらしい。
　emplaceはコンストラクタ引数から直接渡すからpushより早い？のかも

OnCollision内のエラー：OnCollision内で当たり判定を消す処理をしちゃうとOnCollisionはcolliderListをイテレータで回してる最中にあるから、
　そりゃ当たり判定してる時にcolliderListが減っちゃったらイテレータエラー出るよなって感じ

Transformについて：GameObjectのコンストラクタで、そのクラスの親のTransformを呼び出して、pParentに入れて計算する時に使う事で、
　そのモデルをローカル座標にしてる。自分のTrans_rotateを回してから動かしても別に向いてる方向にz進むわけじゃ無いからね。親のTransに依存

CollisionのTranformについて：そのcollisionを付けたオブジェクトのTranformと親のTransformでローカル座標にして、
事前に入れてたcenter分だけずらして描画してる。尚、collisionのdrawはrotateを考慮してない(当たり判定を回す機能が無いため)

無名namespaceについて：他のファイルから参照できない変数にできる。みたいな感じで良いかな

イテレータについて：vectorとかはメモリがつながっている保証があるけど、listはメモリがバラバラだから、普通にポインタを++しちゃうと配列じゃないメモリに
　アクセスしちゃって、変になる。それを防ぐためにイテレータを使えば、ちゃんとその配列が入ってるメモリ順に参照してくれるみたいな

virtualデストラクタについて：ポリモーフィズム(オーバーライドとかすること)用に作られた関数なら付けないと派生クラスのデストラクタが呼ばれない
　逆にポリモーフィズムを利用しないならメモリの無駄遣いになるから使わない方が良い

同じモデルを同じ番号で使いまわすデメリット：アニメーションが重複するため、早くなる（確証は無いが待機モーションがそうなった）、Model内でTransformを一々変える必要がある（主にレイキャストの時に不便）

assignとresizeの違い：assignは指定した要素に元々あった要素も全てそれに変える。resizeは第二引数に入れた奴を増えた所だけに代入してくれる。つまり全部変更するか追加したとこだけ変更するかって違い

FLOATじゃなくてfloatを使う理由：FLOATはDirectX側で用意された型で、今後DirectXのアプデ等でゲームをアプデする事があった場合、FLOATの機能が変わっていたら困るからfloatにしました多分。ネットワークの授業でそんなことやってた気がする

視錐台（しすいだい(多分)）：カメラの位置から四角推型の範囲にある、前方クリッピング面と後方クリッピング面の間の範囲の事。説明ムズイ
暗い部屋に立って、正方形の窓から見た景色の例えがちょっとわかりやすかった。窓枠が前方クリッピング面で、後方クリッピング面が視界を最終的に遮るもの（高層ビルとか山の場合もあれば、何もない場合もある）
https://learn.microsoft.com/ja-jp/windows/uwp/graphics-concepts/viewports-and-clipping

行列の掛け算の順番的な：左側にかけるとローカル行列での変換になって、右側ならワールド行列になる。（）で囲めば分かりやすそう。

DirectXの座標系：左手系で行中心の行列を採用してる為、右にかけるとワールドになって左にかけるとローカルになる
	OpenGLは列中心だから逆


