XMFLOAT3はfloat型３つ分メモリが確保されてそう。00が4つ並んでるのが3つ並んでたから

条件付きブレークポイントはwhileのとことかに置くとFPSクソ下がるぞ

priority_quereの昇順にしたやつ全部が昇順になってるわけでは無くて入れたタイミングで小さかったのと一番近い値と一番後ろから交換してるだけ
つまり小さいやつとそれと近い場所のやつ交換してるだけだから値ぐちゃぐちゃだぞ。後ろに２番目に小さかった奴とか言っちゃってる
って思ったけどtopの時にちゃんと昇順になってました。ごめんあさい

listとvectorの違い；vectorはメモリを並べておくから、必ずメモリがつながってるので、あとから一つ要素を追加した時にvectorの後ろのメモリが
　空いてなかった場合そのvectorのメモリを丸々どっかに引っ越さなきゃいけないせいで追加する時少し遅い
liseは別々のメモリに置くから、追加するのが速くて、色々早い。その代わり一つの要素にアクセスするために毎回イテレータを使わないといけない
　からちょっとアクセスがめんどくさい。
別々にアクセスしたいときはvector、順番にアクセスしたいときはlistみたいな感じでいいか。後から追加する予定が無い時もvectorでいいかも

.atと[]の違い:.at()は範囲外にアクセスしたときにちゃんと境界チェックして例外(out.of.raugeみたいな)出すけど[]は無理やりアクセスするから変な値が出る。
	また、mapとかの場合はphpと同じでその要素がない場合それで初期化しちゃうらしい。

push_backとemplace_backの違い:pushは要素をコピーして渡すからコピーコンストラクタとかが逐一呼ばれるからemplaseより重いらしい。
　emplaceはコンストラクタ引数から直接渡すからpushより早い？のかも

OnCollision内のエラー：OnCollision内で当たり判定を消す処理をしちゃうとOnCollisionはcolliderListをイテレータで回してる最中にあるから、
　そりゃ当たり判定してる時にcolliderListが減っちゃったらイテレータエラー出るよなって感じ

Transformについて：GameObjectのコンストラクタで、そのクラスの親のTransformを呼び出して、pParentに入れて計算する時に使う事で、
　そのモデルをローカル座標にしてる。自分のTrans_rotateを回してから動かしても別に向いてる方向にz進むわけじゃ無いからね。親のTransに依存

CollisionのTranformについて：そのcollisionを付けたオブジェクトのTranformと親のTransformでローカル座標にして、
事前に入れてたcenter分だけずらして描画してる。尚、collisionのdrawはrotateを考慮してない(当たり判定を回す機能が無いため)

無名namespaceについて：他のファイルから参照できない変数にできる。みたいな感じで良いかな

イテレータについて：vectorとかはメモリがつながっている保証があるけど、listはメモリがバラバラだから、普通にポインタを++しちゃうと配列じゃないメモリに
　アクセスしちゃって、変になる。それを防ぐためにイテレータを使えば、ちゃんとその配列が入ってるメモリ順に参照してくれるみたいな

virtualデストラクタについて：ポリモーフィズム(オーバーライドとかすること)用に作られた関数なら付けないと派生クラスのデストラクタが呼ばれない
　逆にポリモーフィズムを利用しないならメモリの無駄遣いになるから使わない方が良い

同じモデルを同じ番号で使いまわすデメリット：アニメーションが重複するため、早くなる（確証は無いが待機モーションがそうなった）、Model内でTransformを一々変える必要がある（主にレイキャストの時に不便）

assignとresizeの違い：assignは指定した要素に元々あった要素も全てそれに変える。resizeは第二引数に入れた奴を増えた所だけに代入してくれる。つまり全部変更するか追加したとこだけ変更するかって違い

FLOATじゃなくてfloatを使う理由：FLOATはDirectX側で用意された型で、今後DirectXのアプデ等でゲームをアプデする事があった場合、FLOATの機能が変わっていたら困るからfloatにしました多分。ネットワークの授業でそんなことやってた気がする

視錐台（しすいだい(多分)）：カメラの位置から四角推型の範囲にある、前方クリッピング面と後方クリッピング面の間の範囲の事。説明ムズイ
暗い部屋に立って、正方形の窓から見た景色の例えがちょっとわかりやすかった。窓枠が前方クリッピング面で、後方クリッピング面が視界を最終的に遮るもの（高層ビルとか山の場合もあれば、何もない場合もある）
https://learn.microsoft.com/ja-jp/windows/uwp/graphics-concepts/viewports-and-clipping

行列の掛け算の順番的な：左側にかけるとローカル行列での変換になって、右側ならワールド行列になる。（）で囲めば分かりやすそう。

DirectXの座標系：左手系で行中心の行列を採用してる為、右にかけるとワールドになって左にかけるとローカルになる
	OpenGLは列中心だから逆

ワールド行列の情報：スケールと回転は、x軸の情報が欲しかったらx軸の単位ベクトル(1,0,0,0)を行列に掛け算すれば、一番上の値だけ持ってこれる。
yが欲しければy軸の単位ベクトルで、そんな感じでやるとそれぞれの行のx軸スケールとかy軸回転角度が取れるらしい。
ちなみに行列は一番から順番にx,y,zの角度と回転を保持してて、一番下の4行目は平行移動を管理してる。ので一番下を持ってくれば平行移動のやつになる。
一番右はオフセットを無視するかしないか的な？ｗはよくわからん

Template関数をヘッダで書く理由：cppファイルに分けて書いて、mainとか他のファイルで使おうとするとリンカエラーが出る。objファイルが作られても情報が無いとか何とかで

リンカエラー見たいな複数回定義されてるやつ：namespaceとかのヘッダーだけで関数等を宣言してるやつだと複数のクラスでincludeしちゃうとnamespaceの関数を何度も複数のクラスで定義しちゃう事になっちゃうから、エラーが起きる。global.hはstaticにしてるから大丈夫ってやつね

コピーコンストラクタ：すでにnewしたクラスを同じ型のクラスに代入する時に呼ばれるコンストラクタの事らしい。もしポインタ等があった場合は
		同じメモリをお互いに参照することになってしまうので注意。=でポインタをセットするよく使ってるやつやね

ムーブコンストラクタ：std::move関数を使ってクラスを代入すること。これを使って変数ポインタを移動させた場合元の変数はおかしな値になる

純粋仮想デストラクタ：デストラクタにvirtualと=0がついてると、仮にメンバ関数がすべて実装をしなければならなくても純粋仮想関数にすることができる。尚、その場合はデストラクタの実装を書かなければリンカエラーが起きるので、{}で定義をしておく

